{% include 'primegenerator.jinja' %}
{% block content %} 

<script src="https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js"></script>
<script src="https://peterolson.github.io/BigInteger.js/BigInteger.min.js"></script>

<script>
    function custom_parseInt(hash) {
        var seed = "";
        for(let i = 0; i < hash.length; i++){
            let number = parseInt(hash.charAt(i), 16);
            seed += parseInt(hash.charAt(i), 16).toString();
        }
        return seed;
    }

    function custom_rand_key(hash) {
        let seed = custom_parseInt(hash);

        return bigInt(seed);
    }

    let received_messages = [];
    let known_keys = {};
    let connected_user = null;

    let g = bigInt(1231);
    let p = get_prime();//9007199254740881; //Largest prime we can make work. 
    let secret = custom_rand_key(sessionStorage.getItem("key"));

    function encrypt(message) {
        return message;
    }

    function decrypt(encryptedMessage) {
        return encryptedMessage;
    }

    function modularPow(base, exponent, modulus) {
        var outcome = base.modPow(exponent,modulus);
        console.log(outcome,"The following is a proper good output");
        return outcome;
    }

    function check_existing_key(user_name) {
        return (user_name in known_keys);
    }

    function receiver(message) { //Accepts all the key-exchange relevent messages. 
        let message_obj = JSON.parse(message);
        message_obj['message'] = JSON.parse(message_obj['message']);
        console.log("triggered reciever",message_obj);

        if (message_obj["sender"] == connected_user && message_obj["message"]["type"] == "ciphertext") {
            console.log("Recieved message from connected user. Appending message");
            append_message_content(decrypt(message_obj["message"]['content']),message_obj["sender"]);
        } else if (message_obj["message"]["type"] == "key_exchange") {
            if (message_obj['message']['sequence_num'] == 0) {
                console.log("Responding to key exchange");
                respond_key_exchange(message_obj["sender"]); //If this is the first messages recieved to init a key exchange, it goes straight to the respond to exchange funcion
            } else {
                received_messages.push(message_obj);
                console.log("Storing message for pass over.");
            }           
        }
    }

    async function init_connection(reciever_user_name) {
        if (!(check_existing_key(reciever_user_name))) {
            await init_key_exchange(reciever_user_name);
        }
        if (check_existing_key(reciever_user_name)) {
            connected_user = reciever_user_name;
        }
    }
</script>

<script>
    function craft_key_exchange_communication(content, sequence_num) {
        return JSON.stringify({
            type: "key_exchange",
            content: content,
            sequence_num: sequence_num
        });
    }

    function craft_message_communication(message) {
        var new_message = JSON.stringify({
            type: "ciphertext",
            content: encrypt(message),
            sequence_num: null
        });
        console.log(new_message);
        return new_message;
    }

    function get_recieved_message(expected_sequence_num,sender) {
        let found_message;
        for (var x = 0; x < received_messages.length; x++) {
            if (received_messages[x]['sender'] == sender) {
                if (received_messages[x]['message']['sequence_num'] == expected_sequence_num) {
                    found_message = received_messages[x]['message'];
                    received_messages.splice(x, 1);
                    return found_message;
                }
            }
        }
        return null;
    }

    async function check_responce_timeout(sequence_num,recipient) {
        recieved_message = null; 
        for (let x = 0; x < 5; x++) {
            console.log("Checking");
            recieved_message = get_recieved_message(sequence_num,recipient);
            if (!(recieved_message == null)) {
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        return recieved_message; 
    }

    async function init_key_exchange(recipient) {
        var public_value = await modularPow(g,secret,p);
        let recieved_message = null; 
        
        let sequence_num = 0; 
        relay(craft_key_exchange_communication("",sequence_num),recipient);
        
        sequence_num += 1; 
        await check_responce_timeout(sequence_num,recipient);

        sequence_num += 1; 
        relay(craft_key_exchange_communication(public_value,sequence_num),recipient);
        sequence_num += 1; 
        recieved_message = await check_responce_timeout(sequence_num,recipient);
                console.log("hit");
        if (!(recieved_message == null)){
                    console.log("hit 2");
            known_keys[recipient] = modularPow(bigInt(recieved_message['content']),secret,p);
                    console.log("hit 3");
            console.log("shared key established:",known_keys[recipient]);
        }
    }

    async function respond_key_exchange(sender) {
        var public_value = modularPow(g,secret,p);
        let recieved_message = null; 

        let sequence_num = 1;
        relay(craft_key_exchange_communication("",sequence_num),sender);

        sequence_num += 1; 
        recieved_message = await check_responce_timeout(sequence_num,sender);

        sequence_num += 1; 
        relay(craft_key_exchange_communication(public_value,sequence_num),sender);

        known_keys[sender] = modularPow(bigInt(recieved_message['content']),secret,p);
        console.log("shared key established:",known_keys[sender]);
    }
</script>

{% endblock %}